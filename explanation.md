# Explanation of 3 complex parts of my code

## 1 - Worms

Worms are the little guys that pop up at random locations that the players compete to kill. Their logic is implemented in the Worms.js file. There is an array called worms which stores objects containing and x and y value, which represents the position of the worm of the grid. Each object in the array is it's own unique worm. There are 12 worms which are randomly spawned in at the start of the game (initialized at the bottom of Worms.js). The logic for random spawning is implemented in spawnWorm, which chooses two random int values between 0 and 25 and simply pushes a new worm positioned at those coordinates. This function is also called very time a player kills a worm, which leads us into the checkWorm function. The checkWorm function is called for a tile whenever it is attacked by either player. It takes an x and y position, as well as the attacking player as parameters, and it loops through each worm to check it any worm is located at the attacked position. If there is a worm there, it calls spawnWorm and updates the score of the attacking player. The movement of the worms is implemented in update function. It loops through each worm and moves it in a random direction. If the worm moves off the edge of a grid, it immediately pushes the worm back so that it doesn't go off-screen. Finally, the checkVictory function is called in the update loop and it checks the whether the number of worms killed by either player is greater than or equal to 50. If it is, it calls a victory/draw handler accordingly.

## 2 - Fireball, Ice, and Zap Attacks

These are the three different types of attacks that the players can use. They are all implemented in their respective files (Fireball.js, Ice.js, and Zap.js). I will use zap as an example, but the others are very similar with a few tweaks. Zap is just one object, as there can only be one attack present on the screen. It contains an x and y value indicating it's position on the grid, as well as a power value indicating the number of squares it has yet to travel. The power value also indicates the reload time - a user can only attack when the power is 0. There is also a separate direction object indicating the direction that the zap is travelling in. When a player presses the attack button, it calls the createZap function, which takes the x and y values of the square in front of the player, as well as the direction of the attack as parameters. It sets the position and direction of the zap accordingly, and sets its power to 7. The zap object is updated in the update function, which is called every frame. It moves the zap object one square in the proper direction each frame, and decrements its power value while also calling checkWorm. If there is an edge, the position and power all gets set to 0. The draw function is also called every frame, and it places the zap sprite wherever it needs to be, including when the power reaches zero and the attack explodes into a sort-of diamond shape (where it calls checkworm in the range of the explosion). This exact system is duplicated for player two.

## 3 - Toggle element

The ability for players to toggle their element is implemented in Select.js. When the user presses their designated toggle key while the game is ongoing, it first calls clearSelection, which clears the styling of the sprites indicating which element is selected. It then sets the selection for the player to the "next" element (fire -> zap -> ice -> fire), and then sets the styling of the newly selected element. The selection is set to zap by default, and it is exported to PlayerOne.js and PlayerTwo.js, where it is used to determine which attack to use when the user presses the attack button.